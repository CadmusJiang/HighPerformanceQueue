# 高性能队列

## 方法
1.初始化大小
2.放进去元素
3.拿出元素
4.stop静止继续放入元素，但允许处理队列中剩下的。


从CPU到
大约需要的CPU周期
大约需要的时间




主存

约60-80纳秒


QPI 总线传输(between sockets, not drawn)

约20ns


L3 cache
约40-45 cycles
约15ns


L2 cache
约10 cycles
约3ns


L1 cache
约3-4 cycles
约1ns


寄存器

1 cycle


Lock	26000ms
CAS	4840ms
无锁	197ms

##优化思路
1.高性能队列可能会特别场，如果采用链表GC roots时负担特别重，因此采用环线数组。数组在读取时因为缓存行的优化也有性能优势
2.如果采用重量级锁进行管理，每次都需要进入内核态，上下文切换开销交大，因此采用cas的方式。同时虽然在高度竞争的环境下，cas因为存在大量的无效操作
会性能下降，但在更多时候乐观锁的机制反而更加高校，高度竞争情况比较少见
3.存在多个生产者同时写的需求，因此参考jvm内存分配方面的思路，给每个生产者分配一段内存，彼此之间写的时候互不影响，减少锁的粒度
4.因为提前预分配了一段空间，因此存在没有写入数据的间隙，所以另外维护一个与生产空间大小相同的available数组来表示哪些写入成功了，写的时候
双写
5.同时因为是一个队列存在一个对象管理，在一般情况下伪共享对性能的影响不大，但是在高性能场景中还是要避免的

实际上，在这些框架中取余并不是使用%运算，都是使用的&与运算，这就要求你设置的大小一般是2的N次方也就是，10,100,1000等等，这样减去1的话就是，1，11，111，就能很好的使用index & (size -1),这样利用位运算就增加了访问速度。
如果在Disruptor中你不用2的N次方进行大小设置，他会抛出buffersize必须为2的N次方异常。

##类对象

